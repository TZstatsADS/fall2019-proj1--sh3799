unnest_tokens(bigram, stemmedwords, token = "ngrams", n = 2)
bigram_counts <- lyric_bigrams %>%
separate(bigram, c("word1", "word2"), sep = " ") %>%
count(word1, word2, sort = TRUE)
combined_words <- apply(bigram_counts[c(1, 2)], 1, paste , collapse = " " )[1:input$topBigrams]
x_names <- factor(combined_words, levels = rev(combined_words))
plot_ly(
x = bigram_counts$n[1:input$topBigrams],
y = x_names,
name = "Bigram",
type = "bar",
orientation = 'h'
)
})
output$table <- DT::renderDataTable({
DT::datatable(dt_lyrics)
})
}
shinyApp(ui, server)
?VCorpus
library(tidyverse)
library(tidytext)
library(plotly)
library(DT)
library(tm)
library(data.table)
library(scales)
library(wordcloud2)
library(gridExtra)
library(ngram)
library(shiny)
# load lyrics data
load('../output/processed_lyrics.RData')
# load artist information
dt_artist <- fread('../data/artists.csv')
lyrics_list <- c("Folk", "R&B", "Electronic", "Jazz", "Indie", "Country", "Rock", "Metal", "Pop", "Hip-Hop", "Other")
time_list <- c("1970s", "1980s", "1990s", "2000s", "2010s")
corpus <- VCorpus(VectorSource(dt_lyrics$stemmedwords))
word_tibble <- tidy(corpus) %>%
select(text) %>%
mutate(id = row_number()) %>%
unnest_tokens(word, text)
# Define UI for app that draws a histogram ----
ui <- navbarPage(strong("Lyrics Analysis"),
tabPanel("Overview",
titlePanel("Most frequent words"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
sliderInput(inputId = "nwords1",
label = "Number of terms in the first word cloud:",
min = 5, max = 100, value = 50),
selectInput('genre1', 'Genre of the first word cloud',
lyrics_list, selected='Folk')
),
# Main panel for displaying outputs ----
mainPanel(
wordcloud2Output(outputId = "WC1", height = "300")
)
),
hr(),
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
sliderInput(inputId = "nwords2",
label = "Number of terms in the second word cloud:",
min = 5, max = 100, value = 50),
selectInput('genre2', 'Genre of the second word cloud',
lyrics_list, selected='Metal')
),
# Main panel for displaying outputs ----
mainPanel(
wordcloud2Output(outputId = "WC2", height = "300")
)
)
),
tabPanel("Time Variation",
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
selectInput('decade1', 'Selected decade for the first plot:',
time_list, selected='1970s'),
selectInput('decade2', 'Selected decade for the second plot:',
time_list, selected='1980s'),
numericInput(inputId = "topBigrams",
label = "Number of top pairs to view:",
min = 1,
max = 20,
value = 10)
),
# Main panel for displaying outputs ----
mainPanel(
fluidRow(
column(5,
plotlyOutput("bigram1")),
column(5,
plotlyOutput("bigram2"))
)
)
)
),
tabPanel("Data",
DT::dataTableOutput("table"))
)
server <- function(input, output) {
output$WC1 <- renderWordcloud2({
count(filter(word_tibble, id %in% which(dt_lyrics$genre == input$genre1)), word, sort = TRUE) %>%
slice(1:input$nwords1) %>%
wordcloud2(size=0.6, rotateRatio=0.2)
})
output$WC2 <- renderWordcloud2({
count(filter(word_tibble, id %in% which(dt_lyrics$genre == input$genre2)), word, sort = TRUE) %>%
slice(1:input$nwords2) %>%
wordcloud2(size=0.6, rotateRatio=0.2)
})
output$bigram1 <- renderPlotly({
year_start <- as.integer(substr(input$decade1, 1, 4))
dt_sub <- filter(dt_lyrics, year>=year_start) %>%
filter(year<(year_start+10))
lyric_bigrams <- dt_sub %>%
unnest_tokens(bigram, stemmedwords, token = "ngrams", n = 2)
bigram_counts <- lyric_bigrams %>%
separate(bigram, c("word1", "word2"), sep = " ") %>%
count(word1, word2, sort = TRUE)
combined_words <- apply(bigram_counts[c(1, 2)], 1, paste , collapse = " " )[1:input$topBigrams]
x_names <- factor(combined_words, levels = rev(combined_words))
plot_ly(
x = bigram_counts$n[1:input$topBigrams],
y = x_names,
name = "Bigram",
type = "bar",
orientation = 'h'
)
})
output$bigram2 <- renderPlotly({
year_start <- as.integer(substr(input$decade2, 1, 4))
dt_sub <- filter(dt_lyrics, year>=year_start) %>%
filter(year<(year_start+10))
lyric_bigrams <- dt_sub %>%
unnest_tokens(bigram, stemmedwords, token = "ngrams", n = 2)
bigram_counts <- lyric_bigrams %>%
separate(bigram, c("word1", "word2"), sep = " ") %>%
count(word1, word2, sort = TRUE)
combined_words <- apply(bigram_counts[c(1, 2)], 1, paste , collapse = " " )[1:input$topBigrams]
x_names <- factor(combined_words, levels = rev(combined_words))
plot_ly(
x = bigram_counts$n[1:input$topBigrams],
y = x_names,
name = "Bigram",
type = "bar",
orientation = 'h'
)
})
output$table <- DT::renderDataTable({
DT::datatable(dt_lyrics)
})
}
shinyApp(ui, server)
knitr::opts_chunk$set(echo = TRUE)
library(tm)
library(data.table)
library(tidytext)
library(tidyverse)
library(DT)
# load lyrics data
load('../data/lyrics.RData')
# function for removimg leading and trailing whitespace from character strings
leadingWhitespace <- content_transformer(function(x) str_trim(x, side = "both"))
ï¼Ÿcontent_transformer()
?content_transformer
?str_trim
# remove stop words
data("stop_words")
force(stop_words)
View(stop_words)
word <- c("lot", "today", "months", "month", "wanna", "wouldnt", "wasnt", "ha", "na", "ooh", "da",
"gonna", "im", "dont", "aint", "wont", "yeah", "la", "oi", "nigga", "fuck",
"hey", "year", "years", "last", "past", "feel")
stop_words <- c(stop_words$word, word)
# clean the data and make a corpus
corpus <- VCorpus(VectorSource(dt_lyrics$lyrics))%>%
tm_map(content_transformer(tolower))%>%
tm_map(removePunctuation)%>%
tm_map(removeWords, character(0))%>%
tm_map(removeWords, stop_words)%>%
tm_map(removeNumbers)%>%
tm_map(stripWhitespace)%>%
tm_map(leadingWhitespace)
library(tidyverse)
library(tidytext)
library(plotly)
library(DT)
library(tm)
library(data.table)
library(scales)
library(wordcloud2)
library(gridExtra)
library(ngram)
library(shiny)
# load lyrics data
load('../output/processed_lyrics.RData')
# load artist information
dt_artist <- fread('../data/artists.csv')
lyrics_list <- c("Folk", "R&B", "Electronic", "Jazz", "Indie", "Country", "Rock", "Metal", "Pop", "Hip-Hop", "Other")
time_list <- c("1970s", "1980s", "1990s", "2000s", "2010s")
corpus <- VCorpus(VectorSource(dt_lyrics$stemmedwords))
word_tibble <- tidy(corpus) %>%
select(text) %>%
mutate(id = row_number()) %>%
unnest_tokens(word, text)
# Define UI for app that draws a histogram ----
ui <- navbarPage(strong("Lyrics Analysis"),
tabPanel("Overview",
titlePanel("Most frequent words"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
sliderInput(inputId = "nwords1",
label = "Number of terms in the first word cloud:",
min = 5, max = 100, value = 50),
selectInput('genre1', 'Genre of the first word cloud',
lyrics_list, selected='Folk')
),
# Main panel for displaying outputs ----
mainPanel(
wordcloud2Output(outputId = "WC1", height = "300")
)
),
hr(),
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
sliderInput(inputId = "nwords2",
label = "Number of terms in the second word cloud:",
min = 5, max = 100, value = 50),
selectInput('genre2', 'Genre of the second word cloud',
lyrics_list, selected='Metal')
),
# Main panel for displaying outputs ----
mainPanel(
wordcloud2Output(outputId = "WC2", height = "300")
)
)
),
tabPanel("Time Variation",
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
selectInput('decade1', 'Selected decade for the first plot:',
time_list, selected='1970s'),
selectInput('decade2', 'Selected decade for the second plot:',
time_list, selected='1980s'),
numericInput(inputId = "topBigrams",
label = "Number of top pairs to view:",
min = 1,
max = 20,
value = 10)
),
# Main panel for displaying outputs ----
mainPanel(
fluidRow(
column(5,
plotlyOutput("bigram1")),
column(5,
plotlyOutput("bigram2"))
)
)
)
),
tabPanel("Data",
DT::dataTableOutput("table"))
)
server <- function(input, output) {
output$WC1 <- renderWordcloud2({
count(filter(word_tibble, id %in% which(dt_lyrics$genre == input$genre1)), word, sort = TRUE) %>%
slice(1:input$nwords1) %>%
wordcloud2(size=0.6, rotateRatio=0.2)
})
output$WC2 <- renderWordcloud2({
count(filter(word_tibble, id %in% which(dt_lyrics$genre == input$genre2)), word, sort = TRUE) %>%
slice(1:input$nwords2) %>%
wordcloud2(size=0.6, rotateRatio=0.2)
})
output$bigram1 <- renderPlotly({
year_start <- as.integer(substr(input$decade1, 1, 4))
dt_sub <- filter(dt_lyrics, year>=year_start) %>%
filter(year<(year_start+10))
lyric_bigrams <- dt_sub %>%
unnest_tokens(bigram, stemmedwords, token = "ngrams", n = 2)
bigram_counts <- lyric_bigrams %>%
separate(bigram, c("word1", "word2"), sep = " ") %>%
count(word1, word2, sort = TRUE)
combined_words <- apply(bigram_counts[c(1, 2)], 1, paste , collapse = " " )[1:input$topBigrams]
x_names <- factor(combined_words, levels = rev(combined_words))
plot_ly(
x = bigram_counts$n[1:input$topBigrams],
y = x_names,
name = "Bigram",
type = "bar",
orientation = 'h'
)
})
output$bigram2 <- renderPlotly({
year_start <- as.integer(substr(input$decade2, 1, 4))
dt_sub <- filter(dt_lyrics, year>=year_start) %>%
filter(year<(year_start+10))
lyric_bigrams <- dt_sub %>%
unnest_tokens(bigram, stemmedwords, token = "ngrams", n = 2)
bigram_counts <- lyric_bigrams %>%
separate(bigram, c("word1", "word2"), sep = " ") %>%
count(word1, word2, sort = TRUE)
combined_words <- apply(bigram_counts[c(1, 2)], 1, paste , collapse = " " )[1:input$topBigrams]
x_names <- factor(combined_words, levels = rev(combined_words))
plot_ly(
x = bigram_counts$n[1:input$topBigrams],
y = x_names,
name = "Bigram",
type = "bar",
orientation = 'h'
)
})
output$table <- DT::renderDataTable({
DT::datatable(dt_lyrics)
})
}
shinyApp(ui, server)
View(ui)
View(dt_lyrics)
library(tm)
library(data.table)
library(tidytext)
library(tidyverse)
library(DT)
# load lyrics data
load('../data/lyrics.RData')
# function for removimg leading and trailing whitespace from character strings
leadingWhitespace <- content_transformer(function(x) str_trim(x, side = "both"))
# remove stop words
data("stop_words")
word <- c("lot", "today", "months", "month", "wanna", "wouldnt", "wasnt", "ha", "na", "ooh", "da",
"gonna", "im", "dont", "aint", "wont", "yeah", "la", "oi", "nigga", "fuck",
"hey", "year", "years", "last", "past", "feel")
stop_words <- c(stop_words$word, word)
# clean the data and make a corpus
corpus <- VCorpus(VectorSource(dt_lyrics$lyrics))%>%
tm_map(content_transformer(tolower))%>%
tm_map(removePunctuation)%>%
tm_map(removeWords, character(0))%>%
tm_map(removeWords, stop_words)%>%
tm_map(removeNumbers)%>%
tm_map(stripWhitespace)%>%
tm_map(leadingWhitespace)
stemmed <- tm_map(corpus, stemDocument) %>%
tidy() %>%
select(text)
dict <- tidy(corpus) %>%
select(text) %>%
unnest_tokens(dictionary, text)
completed <- stemmed %>%
mutate(id = row_number()) %>%
unnest_tokens(stems, text) %>%
bind_cols(dict)
completed <- completed %>%
group_by(stems) %>%
count(dictionary) %>%
mutate(word = dictionary[which.max(n)]) %>%
ungroup() %>%
select(stems, word) %>%
distinct() %>%
right_join(completed) %>%
select(-stems)
save(dt_lyrics, file="../output/processed_lyrics.RData")
knitr::opts_chunk$set(echo = TRUE)
sal.f <- c(3900,4020,4290)
sal.f <- c(3900, 4020, 4290, 4380, 4380, 4380, 4380, 4380, 4440, 4500, 4500, 4620, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4980, 5100, 5100, 5100, 5100, 5100, 5100, 5160, 5220, 5220, 5280, 5280, 5280, 5400, 5400, 5400, 5400, 5400, 5400, 5400, 5400, 5400, 5400, 5400, 5400, 5520, 5520)
sal.m <- c(4620, 5040, 5100, 5100, 5220, 5400, 5400, 5400, 5400, 5400, 5700, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6300, 6600, 6600, 6600, 6840, 6900, 6900, 8100)
gender <- c(rep(FEMALE,n(sal.f)),rep(MALE,n(sal.m)))
gender <- c(rep("FEMALE",n(sal.f)),rep("MALE",n(sal.m)))
gender <- c(rep("FEMALE",length(sal.f)),rep("MALE",length(sal.m)))
length(sal.m)
salary <- data.frame(sal.f,gender)
sal <- c(sal.f, sal.m)
salary <- data.frame(sal,gender)
View(salary)
library(ggplot2)
ggplot(salary,aes(y=sal))+
geom_boxplot()
ggplot(salary,aes(x=gender,y=sal))+
geom_boxplot()
ggplot(salary,aes(x=gender,y=sal))+
geom_boxplot()+coord_flip()
library(ggplot2)
ggplot(salary,aes(x=gender,y=sal))+
geom_boxplot()+coord_flip()+ggtitle("Boxplot for Female and Male salary")
ggplot(salary,aes(y=sal))+
geom_boxplot()+coord_flip()+ggtitle("Boxplot for salary of all gender")
sd.m <- sd(salary$sal)
sd.m
sd.m <- sd(salary[salary$gender=="MALE",]$sal)
sd.m
sd(sal.m)
sd.m <- sd(salary[salary$gender=="MALE",]$sal)
sd.m
sd(sal.m)
sd.m <- sd(salary[salary$gender=="MALE",]$sal)
sd.f <- sd(salary[salary$gender=="FEMALE",]$sal)
IQR(salary[salary$gender=="MALE",])
IQR(c(1,2,3,4,5))
IQR(salary[salary$gender=="MALE",]$sal)
sd.m <- sd(salary[salary$gender=="MALE",]$sal)
sd.f <- sd(salary[salary$gender=="FEMALE",]$sal)
iqr.m <- IQR(salary[salary$gender=="MALE",]$sal)
iqr.f <- IQR(salary[salary$gender=="FEMALE",]$sal)
sd.m <- sd(salary[salary$gender=="MALE",]$sal)
sd.f <- sd(salary[salary$gender=="FEMALE",]$sal)
iqr.m <- IQR(salary[salary$gender=="MALE",]$sal)
iqr.f <- IQR(salary[salary$gender=="FEMALE",]$sal)
# Stadndard deviation of salary for male is
sd.m
# Interquartile range of salary for male is
iqr.m
# Stadndard deviation of salary for female is
sd.f
# Interquartile range of salary for female is
iqr.f
?jackknife()
install.packages("bootstrap")
library(bootstrap)
jackknife(salary[salary$gender=="MALE",]$sal,IQR())
iqr <- function(x){IQR(x)}
sd.salary <- function(x){sd(x)}
jackknife(salary[salary$gender=="MALE",]$sal,iqr)
# Jackknife
library(bootstrap)
iqr <- function(x){IQR(x)}
sd.salary <- function(x){sd(x)}
m.iqr.jack <- jackknife(salary[salary$gender=="MALE",]$sal,iqr)
m.sd.jack <- jackknife(salary[salary$gender=="MALE",]$sal,sd.salary)
f.iqr.jack <- jackknife(salary[salary$gender=="FEMALE",]$sal,iqr)
f.sd.jack <- jackknife(salary[salary$gender=="FEMALE",]$sal,sd.salary)
m.iqr.jack
# Variance estimated by jackknife, for Stadndard deviation of salary for male is
m.sd.jack$jack.se^2
# Bias estimated by jackknife, for Stadndard deviation of salary for male is
m.sd.jack$jack.bias
m.iqr.bs <- bootstrap(salary[salary$gender=="MALE",]$sal,1000,iqr)
m.sd.bs <- bootstrap(salary[salary$gender=="MALE",]$sal,1000,sd.salary)
f.iqr.bs <- bootstrap(salary[salary$gender=="FEMALE",]$sal,1000,iqr)
f.sd.bs <- bootstrap(salary[salary$gender=="FEMALE",]$sal,1000,sd.salary)
m.iqr.bs
var(m.iqr.bs)
var(m.iqr.bs$thetastar)
# Variance estimated by bootstrap, for IQR of salary for female is
var(f.iqr.bs$thetastar)
View(m.iqr.bs)
# Bootstrap
m.iqr.bs <- bootstrap(salary[salary$gender=="MALE",]$sal,100,iqr)
View(m.iqr.bs)
# Jackknife
library(bootstrap)
iqr <- function(x){IQR(x)}
sd.salary <- function(x){sd(x)}
m.iqr.jack <- jackknife(salary[salary$gender=="MALE",]$sal,iqr)
m.sd.jack <- jackknife(salary[salary$gender=="MALE",]$sal,sd.salary)
f.iqr.jack <- jackknife(salary[salary$gender=="FEMALE",]$sal,iqr)
f.sd.jack <- jackknife(salary[salary$gender=="FEMALE",]$sal,sd.salary)
# Variance estimated by jackknife, for Stadndard deviation of salary for male is
m.sd.jack$jack.se^2
# Bias estimated by jackknife, for Stadndard deviation of salary for male is
m.sd.jack$jack.bias
# Variance estimated by jackknife, for IQR of salary for male is
m.iqr.jack$jack.se^2
# Bias estimated by jackknife, for IQR of salary for male is
m.iqr.jack$jack.bias
# Variance estimated by jackknife, for Stadndard deviation of salary for female is
f.sd.jack$jack.se^2
# Bias estimated by jackknife, for Stadndard deviation of salary for female is
f.sd.jack$jack.bias
# Variance estimated by jackknife, for IQR of salary for female is
f.iqr.jack$jack.se^2
# Bias estimated by jackknife, for IQR of salary for female is
f.iqr.jack$jack.bias
# Bootstrap
m.iqr.bs <- bootstrap(salary[salary$gender=="MALE",]$sal,1000,iqr)
m.sd.bs <- bootstrap(salary[salary$gender=="MALE",]$sal,1000,sd.salary)
f.iqr.bs <- bootstrap(salary[salary$gender=="FEMALE",]$sal,1000,iqr)
f.sd.bs <- bootstrap(salary[salary$gender=="FEMALE",]$sal,1000,sd.salary)
# Variance estimated by bootstrap, for Stadndard deviation of salary for male is
var(m.sd.bs$thetastar)
# Bias estimated by bootstrap, for Stadndard deviation of salary for male is
# Variance estimated by bootstrap, for IQR of salary for male is
var(m.iqr.bs$thetastar)
# Bias estimated by bootstrap, for IQR of salary for male is
# Variance estimated by bootstrap, for Stadndard deviation of salary for female is
var(f.sd.bs$thetastar)
# Bias estimated by bootstrap, for Stadndard deviation of salary for female is
# Variance estimated by bootstrap, for IQR of salary for female is
var(f.iqr.bs$thetastar)
# Bias estimated by bootstrap, for IQR of salary for female is
# Bias estimated by jackknife, for Stadndard deviation of salary for male is
m.sd.jack$jack.bias
m.sd.jack
mean(m.sd.jack$jack.values)
sd.m-mean(m.sd.jack$jack.values)
sd.m-mean(m.sd.jack$jack.values)
sd.m
m.sd.jack$jack.bias
mean(m.sd.bs$thetastar)-sd.m
